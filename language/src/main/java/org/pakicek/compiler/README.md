# Компилятор в байт-код
В этой директории находится компилятор, преобразующий исходный код программы в байт-код, который можно будет запустить с помощью виртуальной машины.

## Компоненты

### BytecodeCompiler
Главный класс компилятора. Реализует интерфейс `ASTVisitor` для обхода AST.
Преобразует `ProgramNode` (корневой узел AST) в `ProgramImage`, который может быть сериализован в файл `.srbyte` или передан напрямую в виртуальную машину для исполнения.

#### Функции:
- **Генерация инструкций**: Преобразует узлы AST (выражения, операторы, циклы) в соответствующие опкоды (`OpCode`).
- **Управление памятью**: Отслеживает локальные переменные, назначает им индексы в стеке (таблица символов).
- **Управление потоком**: Генерирует инструкции переходов (`JMP`, `JMP_FALSE`) для реализации `if`, `while`, `for`, а также логических операторов `&&` и `||`.
- **Сборка программы**: Собирает код функции `main` и всех объявленных пользовательских функций в единый объект `ProgramImage`.

#### Ключевые особенности
- **Однопроходная компиляция**: Компилятор генерирует код за один проход по AST. Для инструкций перехода "вперед" (например, в `if` или выходе из цикла) используется механизм "patching" (заглушка смещения, которая перезаписывается, когда становится известен адрес назначения).
- **Стековая архитектура**: Компилятор генерирует код для стековой виртуальной машины. Выражения (например, `a + b`) компилируются в постфиксную запись (`LOAD a`, `LOAD b`, `ADD`).
- **Поддержка типов**: Генерирует код для `int`, `float`, `bool` и ссылочных типов (`NEW_STRUCT`, `NEW_ARRAY`) и поддерживает доступ к ним (`GET_FIELD`, `SET_ARRAY` и т.д.).
- **Оптимизация**: Базовая оптимизация (например, свертка констант) выполняется на уровне байт-кода (в JIT), поэтому компилятор генерирует "наивный" код, максимально близкий к AST.

#### Пример работы
Исходный код:
```cpp
if (x > 10) {
    print(x);
}
```
Сгенерированный байт-код:
```cpp
LOAD_LOCAL 0 (x)
LOAD_CONST 10
GT              ; Сравнение x > 10
JMP_FALSE 15    ; Если ложь, прыгнуть на метку 15 (после блока)
LOAD_LOCAL 0 (x)
PRINT
LOAD_CONST VOID ; print возвращает void
POP
... (метка 15) ...
```

### BytecodeIO
Класс, сериализующий `ProgramImage` в файл `.srbyte` и последующей его десериализации.
Это позволяет распространять программы на языке Slowrace в формате `.srbyte` без необходимости повторной компиляции исходного кода.

#### Функции:
- `write(ProgramImage program, String filename)`: Сохраняет объект `ProgramImage` в файл.
- `read(String filename)`: Читает файл и восстанавливает объект `ProgramImage`.

#### Формат файла (.srbyte):
- **Заголовок**:
  - Magic Number: `SLOW` (4 байта ASCII) — идентификатор формата.
  - Version: `1` (4 байта int) — версия формата байт-кода.
- **Функции**:
  - `Count` (int): Количество функций.
  - Для каждой функции:
    - `Name` (UTF String): Имя функции.
    - `Chunk`: Тело функции (см. структуру Chunk).
- **Main Chunk**:
  - `Chunk`: Тело главной функции программы.

#### Структура Chunk (блок кода):
- **Constant Pool (пул констант)**:
  - `Count` (int): Количество констант.
  - Для каждой константы:
    - `Tag` (byte): Тип константы (`0=INT`, `1=FLOAT`, `2=BOOL`, `3=STRING`, `4=VOID`).
    - `Value`: Значение константы (формат зависит от типа, например, для `INT` это массив байтов `BigInteger`).
- **Bytecode (инструкции)**:
  - `Size` (int): Количество байтов кода.
  - `Bytes` (byte[]): Массив опкодов и аргументов.
- **Debug Info (отладочная информация)**:
  - `Lines` (int[]): Массив номеров строк исходного кода, соответствующих каждой инструкции (для трассировки ошибок).

#### Пример использования
```java
// Сохранение
BytecodeIO.write(programImage, "program.srbyte");

// Загрузка
ProgramImage loadedProgram = BytecodeIO.read("program.srbyte");

