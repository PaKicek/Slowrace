# JIT
Здесь находится JIT, отвечающий за оптимизацию байт-кода "на лету" во время исполнения программы.

## Принцип работы
Виртуальная машина отслеживает количество вызовов каждой функции (hot spots).
Когда функция вызывается достаточно часто (превышает порог), её байт-код передается в JIT для оптимизации.
Оптимизированная версия заменяет оригинальную для последующих вызовов.

## Компоненты

### JitOptimizer
Реализует несколько проходов оптимизации над байт-кодом (`Chunk`).

#### Реализованные оптимизации:
- **Constant Folding**:
  - Вычисляет выражения с константами на этапе компиляции.
  - Пример: `LOAD 2, LOAD 3, ADD` -> `LOAD 5`.
  - Поддерживает `int` (BigInteger).
- **Arithmetic Identities**:
  - Упрощает операции с нейтральными элементами.
  - `x + 0` -> `x` (инструкции удаляются).
  - `x * 1` -> `x`.
  - `x * 0` -> `0` (заменяется на `POP, LOAD 0`).
- **Dead Code Elimination**:
  - Использует BFS обход графа инструкций.
  - Определяет инструкции, которые недостижимы ни по одному пути исполнения (например, код после безусловного `RETURN` или `JMP`).
  - Удаляет недостижимые блоки, уменьшая размер программы.
  - Поскольку удаление кода сдвигает адреса инструкций, JIT автоматически пересчитывает смещения для всех инструкций `JMP` и `JMP_FALSE`, чтобы сохранить корректную логику ветвления.